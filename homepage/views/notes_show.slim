.row
  .col-sm-12
    h2.subject
      = @note.subject
    ul.note-tags
      - @note.tags.each do |tag|
        li.note-tag= tag
    .date
      = "Posted at #{@note.date}"

.paragraphs
  - @note.content.paragraphs.each do |p|
    .paragraph
      .row
        h3.paragraph-title.col-sm-12= p.title
      - unless p.editor_hidden?
        .row
          .col-sm-12
            pre.paragraph-text id="text-#{p.id}" data-mode="#{p.editor_mode}"
                = p.text
      - p.results.each do |r|
        .row
          .col-sm-12
            - if r.type === 'HTML' || r.type === 'ANGULAR'
              == r.data
            - elsif r.type === 'GRAPH'
              script.graph type="application/json" data-config="#{r.config.to_json}"
                == r.data
            - else
              pre.paragraph-results id="results-#{p.id}"
                = r.data

sass:
  .paragraph-title
    margin: 1rem 0

  .paragraph-text
    height: 200px
    border: 1px solid rgba(0,0,0,0.05)
    box-shadow: 1px 1px 3px 0px rgba(253, 246, 227, 0.1)

  .ace-solarized-light
    background: rgba(255,255,255,1)

  .paragraph-results
    max-height: 200px
    background: rgba(0,0,0,0.01)
    padding: 16px
    border: 1px solid rgba(0, 0, 0, 0.03)
    box-shadow: 1px 1px 3px 0px rgba(0, 0, 0, 0.01)

javascript:
  (function() {
    const elements = document.getElementsByTagName('code');
    for (let i = 0; i < elements.length; ++i) {
      const el = elements[i];
      if (el.className == '') continue;
      const wrapper = document.createElement('div');
      wrapper.id = 'code-' + i;
      if (el.className == 'cpp') wrapper.dataset.mode = 'ace/mode/c_cpp';

      el.before(wrapper);
      wrapper.appendChild(el);

      setTimeout(() => {
        const editor = ace.edit(wrapper.id, {minLines: 2, maxLines: 15});
        editor.setTheme("ace/theme/solarized_light");
        if (wrapper.dataset.mode) editor.getSession().setMode(wrapper.dataset.mode);
      }, i*100);
    }
  })();

  (function() {
    const elements = document.getElementsByClassName('paragraph-text')
    for (let i = 0; i < elements.length; ++i) {
      const el = elements[i];
      setTimeout(() => {
        const editor = ace.edit(el.id, {minLines: 2, maxLines: 15});
        editor.setTheme("ace/theme/solarized_light");
        if (el.dataset.mode) editor.getSession().setMode(el.dataset.mode);
      }, i*100);
    }
  })();

  (function() {
    const elements = document.getElementsByTagName('iframe');
    for (let i = 0; i < elements.length; ++i) {
      const el = elements[i];
      el.className += ' embed-responsive';
    }
  })();

  // draw graphs
  (function() {
    const elements = document.getElementsByClassName('graph');
    for (let i = 0; i < elements.length; ++i) {
      const script = elements[i];
      const config = JSON.parse(script.dataset.config);

      if (config.mode == 'table') {
        const table = document.createElement('table');
        table.className = 'table';
        const lines = script.innerText.split('\n');
        for (let i = 0; i < lines.length; ++ i) {
          const row = table.insertRow();
          const cell = row.insertCell();
          cell.innerText = lines[i];
        }
        script.parentNode.insertBefore(table, script);
      } else if (config.mode == 'lineChart') {
        const div = document.createElement('div');
        const k = config.keys[0].index;
        const v = config.values[0].index;
        const data = script.innerText.split('\n').map(l => l.split('\t'));
        const points = [];
        for (let i = 1; i < data.length - 1; ++i) {
          points.push({
            key: new Date(data[i][k]),
            value: parseInt(data[i][v], 10)
          });
        }

        // line chart
        const width = 640;
        const height = 300;
        const svg = d3.select(div).append('svg');
        svg.attr('width', width).attr('height', height);
        const x = d3.scaleTime().rangeRound([0, width]);
        const y = d3.scaleLinear().rangeRound([height, 0]);
        const line = d3.line().x(d => x(d.key)).y(d => y(d.value));
        x.domain(d3.extent(points, d => d.key));
        y.domain(d3.extent(points, d => d.value));
        const g = svg.append('g');
        g.append('path')
          .datum(points)
          .attr('fill', 'none')
          .attr('stroke', 'steelblue')
          .attr('stroke-linejoin', 'round')
          .attr('stroke-linecap', 'round')
          .attr('stroke-width', 1.5)
          .attr('d', line);

        script.parentNode.insertBefore(div, script);
      }
    }
  })();
